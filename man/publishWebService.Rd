% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/publish.R
\name{publishWebService}
\alias{publishWebService}
\alias{updateWebService}
\title{Publish a function as a Microsoft Azure Web Service}
\usage{
publishWebService(ws, fun, name, inputSchema, outputSchema,
  data.frame = FALSE, export = character(0), noexport = character(0),
  packages, version = "3.1.0", wsid, host = ws$.management_endpoint)

updateWebService(ws, fun, name, inputSchema, outputSchema, data.frame = FALSE,
  export = character(0), noexport = character(0), packages,
  version = "3.1.0", wsid, host = ws$.management_endpoint)
}
\arguments{
\item{ws}{An AzureML workspace reference returned by \code{\link{workspace}}.}

\item{fun}{a function to publish; the function must have at least one argument}

\item{name}{name of the new web service}

\item{inputSchema}{a list of \code{fun} input parameters and their AzureML types
formatted as \code{list("arg1"="type", "arg2"="type", ...)}; see the note below
for details}

\item{outputSchema}{list of \code{fun} outputs and AzureML types,
formmated as \code{list("output1"="type", "output2"="type", ...)}}

\item{data.frame}{\code{TRUE} indicates that the function \code{fun} accepts a data frame as input
  and returns a data frame output.
\code{\link{workspace}}.}

\item{export}{optional character vector of variable names to explicitly export
in the web service for use by the function. See the note below.}

\item{noexport}{optional character vector of variable names to prevent from exporting
in the web service}

\item{packages}{optional character vector of R packages required by the function}

\item{version}{optional R version string for required packages (the version of R running in the AzureML Web Service)}

\item{wsid}{optional Azure web service ID; use to update an existing service (see Note below)}

\item{host}{optional Azure regional host, defaulting to the global \code{management_endpoint} set in}
}
\value{
A data.frame describing the new service endpoints, cf. \code{\link{endpoints}}. The output can be directly used by the \code{\link{consume}} function.
}
\description{
Publish a function to Microsoft Azure Machine Learning as a web service. The
web service created is a standard Azure ML web service, and can be used
from any web or mobile platform as long as the user knows the API key and URL.
The function to be published is limited to inputs/outputs consisting of
lists of scalar values or single data frames (see the notes below and examples).
}
\note{
AzureML data types are different from, but related to, R types. You may specify the R types \code{numeric, logical, integer,} and \code{character} and those will be specified as AzureML types \code{double, boolean, int32, string}, respectively.

Function input must be:
\enumerate{
\item named scalar arguments with names and types specified in \code{inputSchema}
\item one or more lists of named scalar values
\item a single data frame when \code{data.frame=TRUE} is specified; the column names and types are specified in \code{inputSchema}
}
Function output is always returned as a data frame with column names and types specified in \code{outputSchema}.
See the examples for example use of all three I/O options.

Leave the \code{wsid} parameter undefined to create a new AzureML web service, or specify the ID of an existing web service to update it, replacing the function and required R pacakges with new values. Although the API allows that the name, input and output schema to also be specified when updating it's not possible to change those values.

The \code{\link{updateWebService}} function is nearly an alias for \code{\link{publishWebService}}, differing only in that the \code{wsid} parameter is required by \code{\link{updateWebService}}.

The \code{publishWebService} function automatically exports objects required by the function to a working environment in the AzureML machine, including objects accessed within the function using lexical scoping rules. Use the \code{exports} parameter to explicitly include other objects that are needed. Use \code{noexport} to explicitly prevent objects from being exported.
}
\examples{
\dontrun{
  # Use a default configuration in ~/.azureml, alternatively
  # see help for `workspace`.
  ws <- workspace()
  
  # Really simple example:
  add <- function(x,y) x + y
  endpoint <- publishWebService(ws, 
                                fun = add, 
                                name = "addme", 
                                inputSchema = list(x="numeric", 
                                                   y="numeric"), 
                                outputSchema = list(ans="numeric"))
  consume(endpoint, list(x=pi, y=2))

  # Now remove the web service named "addme" that we just published
  deleteWebService(ws, "addme")

  
  # A neat trick to evaluate any expression in the Azure ML virtual
  # machine R session and view its output:
  ep <- publishWebService(ws, 
                          fun = function(expr) {
                            paste(capture.output(
                              eval(parse(text=expr))), collapse="\\n")
                          },
                          name="commander", 
                          inputSchema = list(x = "character"),
                          outputSchema = list(ans = "character"))
  cat(consume(ep, list(x = "getwd()"))$ans)
  cat(consume(ep, list(x = ".packages(all=TRUE)"))$ans)
  cat(consume(ep, list(x = "R.Version()"))$ans)

  # Remove the service we just published
  deleteWebService(ws, "commander")
  
  # The following example illustrates scoping rules. Note that the function
  # refers to the variable y defined outside the function body. That value
  # will be exported with the service.
  y <- pi
  ep <- publishWebService(ws, 
                          fun = function(x) x + y, 
                          name = "lexical scope",
                          inputSchema = list(x = "numeric"), 
                          outputSchema = list(ans = "numeric"))
  cat(consume(ep, list(x=2))$ans)
  
  # Remove the service we just published
  deleteWebService(ws, "lexical scope")
  
  # Example showing the use of consume to score all the rows of a data frame
  # at once, and other invocations for evaluating multiple sets of input
  # values. The columns of the data frame correspond to the input parameters
  # of the web service in this example:
  f <- function(a,b,c,d) list(sum = a+b+c+d, prod = a*b*c*d)
  ep <-  publishWebService(ws, 
                           f, 
                           name = "rowSums",
                           inputSchema = list(
                             a="numeric", 
                             b="numeric", 
                             c="numeric", 
                             d="numeric"
                           ),
                           outputSchema = list(
                             sum ="numeric", 
                             prod = "numeric")
  )
  x <- head(iris[,1:4])  # First four columns of iris
  
  # Note the following will FAIL because of a name mismatch in the arguments
  # (with an informative error):
  consume(ep, x, retryDelay=1)
  # We need the columns of the data frame to match the inputSchema:
  names(x) <- letters[1:4]
  # Now we can evaluate all the rows of the data frame in one call:
  consume(ep, x)
  # output should look like:
  #    sum    prod
  # 1 10.2   4.998
  # 2  9.5   4.116
  # 3  9.4  3.9104
  # 4  9.4   4.278
  # 5 10.2    5.04
  # 6 11.4 14.3208

  # You can use consume to evaluate just a single set of input values with this
  # form:
  consume(ep, a=1, b=2, c=3, d=4)

  # or, equivalently,
  consume(ep, list(a=1, b=2, c=3, d=4))

  # You can evaluate multiple sets of input values with a data frame input:
  consume(ep, data.frame(a=1:2, b=3:4, c=5:6, d=7:8))

  # or, equivalently, with multiple lists:
  consume(ep, list(a=1, b=3, c=5, d=7), list(a=2, b=4, c=6, d=8))
  
  # Remove the service we just published
  deleteWebService(ws, "rowSums")

  # If your function can consume a whole data frame at once, you can also
  # supply data in that form, resulting in more efficient computation.
  # The following example builds a simple linear model on a subset of the
  # airquality data and publishes a prediction function based on the model.
  set.seed(1)
  m <- lm(Ozone ~ ., data=airquality[sample(nrow(airquality), 100),])
  # Define a prediction function based on the model:
  fun <- function(newdata)
  {
    predict(m, newdata=newdata)
  }
  # Note the definition of inputSchema and use of the data.frame argument.
  ep <- publishWebService(ws, fun=fun, name="Ozone",
                          inputSchema=lapply(airquality, typeof),
                          outputSchema=list(ans="numeric"),
                          data.frame=TRUE)
  ans = consume(ep, airquality)$ans
  plot(ans, airquality$Ozone)
  deleteWebService(ws, "Ozone")

  # The publishWebService function uses `miniCRAN` to include dependencies on
  # packages required by your function. The next example uses the `lmer`
  # function from the lme4 package, and also shows how to publish a function
  # that consumes a data frame by setting data.frame=TRUE.  Note! This example
  # depends on a lot of packages and may take some time to upload to Azure.
  library(lme4)
  # Build a sample mixed effects model on just a subset of the sleepstudy data...
  set.seed(1)
  m <- lmer(Reaction ~ Days + (Days | Subject), data=sleepstudy[sample(nrow(sleepstudy), 120),])
  # Deine a prediction function to publish based on the model:
  fun <- function(newdata)
  {
    predict(m, newdata=newdata)
  }
  ep <- publishWebService(ws, fun=fun, name="sleepy lmer",
                          inputSchema=lapply(sleepstudy, typeof),  # Note
                          outputSchema=list(ans="numeric"),
                          packages="lme4",                         # Note
                          data.frame=TRUE)                         # Note

  # OK, try this out, and compare with raw data
  ans = consume(ep, sleepstudy)$ans
  plot(ans, sleepstudy$Reaction)
  
  # Remove the service
  deleteWebService(ws, "sleepy lmer")
}
}
\seealso{
\code{\link{endpoints}} \code{\link{discoverSchema}} \code{\link{consume}} \code{\link{services}}

Other publishing functions: \code{\link{deleteWebService}};
  \code{\link{workspace}}
}

